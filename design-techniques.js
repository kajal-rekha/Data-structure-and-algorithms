// dynamic programming: fibonacci
// greedy algorithms: optimal solution for multiple steps
// brute force: best solution among all solutions
// backtracking: different inputs, time complexity varies, justify perfect inputs, different steps, input X steps === comfortable posiiblity
// branch and bound: all solution, best solution, all solution X best solution
// divide and conquer: problem, sub problems, solve through recursively
